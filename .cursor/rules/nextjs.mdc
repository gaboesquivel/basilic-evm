---
description: Next.js development standards and patterns
globs: "app/**/*.{ts,tsx}"
---

# Next.js Best Practices

## Core Principles
- Default to Server Components for better performance
- Minimize 'use client' directives
- Follow App Router patterns and conventions
- Handle errors with proper error boundaries

## Component Architecture
```tsx
// Prefer Server Components by default
export function ServerComponent() {
  return (
    <section className="space-y-4">
      <h1>Server Rendered</h1>
      <ClientComponent />
    </section>
  )
}

// Use 'use client' only when necessary
'use client'
function ClientComponent() {
  const [state, setState] = useState(false)
  return <button onClick={() => setState(!state)}>Toggle</button>
}
```

## Data Fetching
- Use Server Components for data fetching
- Implement proper caching strategies
- Handle loading and error states
- Use proper revalidation patterns

## Route Handlers
- Use Next.js route handlers for API endpoints
- Implement proper error handling
- Follow RESTful conventions
- Use proper response types

## File Conventions
- Use proper loading.tsx for loading states
- Implement error.tsx for error boundaries
- Follow page.tsx convention for routes
- Use layout.tsx for shared layouts

## Server Actions
```tsx
'use server'
import { type ActionResult, success, failure } from '@repo/next'
import { createSafeActionClient } from 'next-safe-action'

export const saveAction = createSafeActionClient()
  .schema(actionSchema)
  .action(async ({ parsedInput }): Promise<ActionResult<T>> => {
    try {
      // Happy path
      return success(result)
    } catch (error) {
      return failure({
        code: 'UNEXPECTED_ERROR',
        error,
        label: 'saveAction'
      })
    }
  })
```


## Performance Patterns
```tsx
// Use Image component with proper sizing
import { Image } from 'next/image'

export function OptimizedImage() {
  return (
    <Image
      src="/hero.webp"
      alt="Hero"
      width={1200}
      height={630}
      priority={true}
      className="w-full"
    />
  )
}

// Use Suspense for loading states
export function LazyComponent() {
  return (
    <Suspense fallback={<LoadingSkeleton />}>
      <ExpensiveComponent />
    </Suspense>
  )
}
```

## Next.js Optimizations
- Use App Router for efficient navigation and state management
- Implement streaming with Suspense for progressive loading
- Follow proper caching strategies:
  - Use fetch cache options appropriately
  - Implement revalidation when needed
- Minimize 'use client' directives to leverage SSR benefits
- Use proper loading.tsx and error.tsx files for better UX 
  

## Services Pattern
```tsx
import { captureAppError } from '@repo/errors'
import type { SupaApiParams } from '../types'

export async function getData({
  params,
  supabase,
}: SupaApiParams & {
  params: DataParams
}) {
  const { data, error } = await supabase
    .from('table')
    .select()
    .single()

  if (error || !data) 
    captureAppError({ 
      code: 'FETCH_ERROR', 
      error, 
      label: 'getData' 
    })

  return data as NonNullable<typeof data>
}
``` 